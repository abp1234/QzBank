

---

## 📘 1장. SQL 처리 과정과 I/O

---

### 🔹 1.1 SQL 파싱과 최적화

| 소목차                           | 내용 요약                                                                                 |
| ----------------------------- | ------------------------------------------------------------------------------------- |
| **1.1.1 구조적, 집합적, 선언적 질의 언어** | SQL은 '무엇을' 원하는지 기술하는 선언적 언어로, 명령의 실행 순서를 직접 지정하지 않음. 집합 기반 연산으로 설계되며, 명령형 언어와 구별됨.    |
| **1.1.2 SQL 최적화**             | SQL을 효율적으로 실행하기 위해 내부적으로 다른 형태로 변환. 옵티마이저가 비용 기반(CBO)으로 후보 실행계획 중 최적 경로를 선택.          |
| **1.1.3 SQL 옵티마이저**           | SQL 실행 경로를 선택하는 핵심 엔진. 규칙 기반(RBO)은 정해진 규칙에 따라, 비용 기반(CBO)은 I/O, CPU 비용 등을 기준으로 경로 선택. |
| **1.1.4 실행계획과 비용**            | 실행계획은 테이블 접근 방식, 조인 순서, 인덱스 사용 여부 등 포함. 비용은 옵티마이저가 경로를 평가하는 기준. 비용이 낮을수록 효율적.         |
| **1.1.5 옵티마이저 힌트**            | SQL 내부에 /\*+ HINT \*/ 형식으로 삽입. 옵티마이저가 특정 인덱스를 강제로 사용하거나 조인 방식을 선택하도록 유도. 튜닝 시 활용.     |

#### ✅ 연습 예제

* `SELECT /*+ INDEX(emp emp_idx) */ * FROM emp WHERE deptno = 10;`
  → 옵티마이저 힌트를 사용하여 인덱스를 강제로 적용하는 실습.

---

### 🔹 1.2 SQL 공유 및 재사용

| 비교 항목  | 소프트 파싱                 | 하드 파싱          |
| ------ | ---------------------- | -------------- |
| 정의     | 기존 실행계획 재사용            | 새로운 실행계획 생성    |
| 처리 비용  | 낮음                     | 높음             |
| 재사용 조건 | 동일한 SQL 문장 + 바인드 변수 사용 | 문장이 완전히 동일해야 함 |

| 소목차                        | 내용 요약                                                                                        |
| -------------------------- | -------------------------------------------------------------------------------------------- |
| **1.2.1 소프트 파싱 vs. 하드 파싱** | 하드 파싱은 SQL을 처음 해석하고 실행계획을 생성하는 과정. 소프트 파싱은 이미 존재하는 실행계획을 재사용함으로써 성능 개선 가능. 바인드 변수 사용이 핵심 조건. |
| **1.2.2 바인드 변수의 중요성**      | 바인드 변수는 SQL 문장의 변동 요소를 변수로 처리함으로써 SQL 캐싱을 유도. 하드 파싱 빈도를 줄여 효율적 자원 사용 통제.                     |

#### ✅ 연습 예제

```sql
-- 하드 파싱 발생
SELECT * FROM emp WHERE empno = 7369;
SELECT * FROM emp WHERE empno = 7499;

-- 바인드 변수 사용 시 소프트 파싱 가능
SELECT * FROM emp WHERE empno = :empno;
```

---

### 🔹 1.3 데이터 저장 구조 및 I/O 메커니즘

| 구분                       | 설명                                                  |
| ------------------------ | --------------------------------------------------- |
| 블록 단위 저장                 | 데이터는 디스크의 블록 단위로 저장되며, I/O 단위도 블록 기준으로 작동           |
| 시퀀셜 vs. 랜덤               | 시퀀셜: 연속 블록 읽기 (빠름), 랜덤: 불연속 블록 접근 (느림)              |
| 논리 I/O vs. 물리 I/O        | 논리 I/O는 메모리 접근, 물리 I/O는 디스크 접근을 의미하며 성능에 큰 영향       |
| Single vs. Multiblock    | 한 번에 하나의 블록만 접근하는 방식과 여러 블록을 한 번에 읽는 방식 구분          |
| Full Scan vs. Index Scan | 전체 테이블을 스캔하는 방식과 인덱스를 이용한 접근 방식 비교                  |
| 캐시 탐색                    | Oracle의 버퍼 캐시 탐색 방식. 먼저 캐시에 있는지 확인 후 물리적 디스크 접근 결정. |

| 소목차                                            | 내용 요약                                                             |
| ---------------------------------------------- | ----------------------------------------------------------------- |
| **1.3.1 SQL이 느린 이유**                           | 불필요한 하드 파싱, 잘못된 실행계획, 비효율적인 I/O 발생 등이 주요 원인. 성능 병목 확인 필수.         |
| **1.3.2 데이터베이스 저장 구조**                         | 테이블, 인덱스, 클러스터 등이 블록 단위로 구성되며 저장 위치에 따라 성능 차이 발생.                 |
| **1.3.3 블록 단위 I/O**                            | Oracle 등 RDBMS는 디스크에서 데이터를 블록 단위로 읽음. 블록 크기와 설정이 성능에 영향.          |
| **1.3.4 시퀀셜 액세스 vs. 랜덤 액세스**                   | 연속된 블록을 읽는 시퀀셜 액세스가 랜덤보다 빠름. Index Range Scan은 랜덤 I/O 포함.         |
| **1.3.5 논리적 I/O vs. 물리적 I/O**                  | 논리적 I/O는 캐시 메모리에서 처리, 물리적 I/O는 디스크 접근. 후자는 비용 높음.                 |
| **1.3.6 Single Block I/O vs. Multiblock I/O**  | Single Block은 인덱스 기반 탐색, Multiblock은 Full Scan 시 사용.              |
| **1.3.7 Table Full Scan vs. Index Range Scan** | Full Scan은 전체 테이블 탐색, Index Scan은 일부만. 조건절, 통계정보, 데이터 분포 등 고려 필요. |
| **1.3.8 캐시 탐색 메커니즘**                           | Oracle은 먼저 버퍼 캐시 확인 후, 없으면 디스크에서 읽음. LRU 방식으로 교체 관리.              |

#### ✅ 연습 예제

* `EXPLAIN PLAN FOR SELECT * FROM emp WHERE sal > 3000;`
  → 실행계획을 확인하여 Table Full Scan 또는 Index Scan 여부 분석.

---

## ✅ 전체 구조 요약 테이블

| 범주             | 키워드 요약                                  |
| -------------- | --------------------------------------- |
| SQL 언어 구조      | 선언적, 집합적, 구조적 질의 방식. 실행 순서 대신 결과 기술에 집중 |
| 파싱과 최적화        | 하드/소프트 파싱, 바인드 변수 활용으로 실행계획 재사용 유도      |
| 옵티마이저 작동 원리    | RBO와 CBO 방식, 힌트로 사용자 개입 가능              |
| 실행계획 평가 기준     | I/O, CPU 비용 수치화 기반의 비용 기반 실행계획 선정       |
| 저장 구조 및 액세스 방식 | 블록 단위 저장, 시퀀셜 vs. 랜덤, 캐시 우선 탐색 메커니즘     |
| 성능 튜닝 고려 사항    | Full Scan 지양, Index 적절 활용, I/O 최소화 전략   |

---

---

## 📘 2장. 인덱스 기본

---

### 🔹 2.1 인덱스 구조 및 탐색

| 소목차                     | 요약                                                                       |
| ----------------------- | ------------------------------------------------------------------------ |
| **2.1.1 미리 보는 인덱스 튜닝**  | 인덱스 튜닝의 전반적 흐름과 필요성 개괄. 조건절, 정렬, 조인 등 다양한 상황에서 인덱스가 어떻게 활용되는지 사전 인식 필요   |
| **2.1.2 인덱스 구조**        | 대부분 B-Tree 기반. 루트-브랜치-리프 노드 구조로 계층적이며 정렬 상태 유지. 각 노드는 포인터를 통해 데이터 위치를 참조 |
| **2.1.3 인덱스 수직적 탐색**    | 루트부터 리프 노드까지 따라가는 트리 탐색 방식. 검색 효율에 핵심적이며 Depth에 따라 성능 영향                 |
| **2.1.4 인덱스 수평적 탐색**    | 리프 노드 간 인접 포인터를 통해 범위 조건에 따라 여러 건을 연속으로 탐색. Range Scan 시 활용              |
| **2.1.5 결합 인덱스 구조와 탐색** | 두 개 이상 컬럼을 포함한 인덱스. 선두 컬럼이 조건절에 포함되어야 효과 발휘. 복합 조건에서 인덱스 효율 극대화          |

#### ✅ 연습 예제

```sql
-- 결합 인덱스가 활용되는 경우
CREATE INDEX idx_emp_dept_sal ON emp(deptno, sal);

-- deptno는 조건절에 있어야 인덱스 사용 가능
SELECT * FROM emp WHERE deptno = 10 AND sal > 3000;
```

---

### 🔹 2.2 인덱스 기본 사용법

| 소목차                                 | 요약                                                         |
| ----------------------------------- | ---------------------------------------------------------- |
| **2.2.1 인덱스를 사용한다는 것**              | 조건절을 기반으로 인덱스를 탐색하여 테이블 접근을 최소화. 전체 테이블 스캔 대비 성능 향상 가능     |
| **2.2.2 인덱스를 Range Scan 할 수 없는 이유** | 결합 인덱스의 후속 컬럼만 조건절에 있을 경우, 범위 탐색 불가능. 선행 컬럼 누락 시 인덱스 무효화   |
| **2.2.3 더 중요한 인덱스 사용 조건**           | WHERE 절 컬럼의 가공 여부, 형변환 여부, 통계 정보에 따른 선택도 고려 등 다양한 요소 판단 필요 |
| **2.2.4 인덱스를 이용한 소트 연산 생략**         | ORDER BY 절이 인덱스 정렬과 일치하면 정렬 연산을 생략 가능. 성능 최적화 유도           |
| **2.2.5 ORDER BY 절에서 컬럼 가공**        | 컬럼 가공 시 인덱스 정렬 무효. 함수 또는 산술 연산 포함 시 인덱스 사용 불가              |
| **2.2.6 SELECT-LIST에서 컬럼 가공**       | 인덱스를 이용한 커버링 인덱스가 가능하려면 SELECT 리스트에도 가공 없이 컬럼이 존재해야 함      |
| **2.2.7 자동 형변환**                    | WHERE절에서 데이터 타입이 일치하지 않으면 자동 형변환 발생. 인덱스 사용이 차단될 수 있음      |

#### ✅ 연습 예제

```sql
-- 인덱스 사용 가능한 조건
SELECT * FROM emp WHERE ename = 'KING';

-- 인덱스 사용 안 되는 조건 (함수 사용)
SELECT * FROM emp WHERE UPPER(ename) = 'KING';

-- 자동 형변환으로 인덱스 미사용
SELECT * FROM emp WHERE empno = '7369'; -- empno는 숫자형
```

---

### 🔹 2.3 인덱스 확장기능 사용법

| 스캔 방식                                 | 설명                                                       |
| ------------------------------------- | -------------------------------------------------------- |
| **2.3.1 Index Range Scan**            | WHERE절 조건이 인덱스 컬럼에 Range 조건으로 적용될 때. 가장 일반적 형태           |
| **2.3.2 Index Full Scan**             | WHERE 절 조건 없이 인덱스의 모든 값을 정렬된 상태로 순차 접근. 정렬된 결과 요구 시 유용   |
| **2.3.3 Index Unique Scan**           | 유일값 검색 시 사용. PK 또는 유니크 인덱스에서만 가능. 1건만 반환되는 조건 필요         |
| **2.3.4 Index Skip Scan**             | 결합 인덱스의 선행 컬럼 조건이 없어도 후속 컬럼으로 추정 검색 수행. 인덱스 구성에 따라 발생 가능 |
| **2.3.5 Index Fast Full Scan**        | 인덱스 블록을 병렬로 비순차 스캔. 정렬 상태 무시, 전체 데이터를 빠르게 읽고자 할 때 사용     |
| **2.3.6 Index Range Scan Descending** | 인덱스를 역순으로 탐색. ORDER BY DESC가 있을 때 유용                     |

#### ✅ 연습 예제

```sql
-- Index Unique Scan
SELECT * FROM emp WHERE empno = 7369;

-- Index Range Scan
SELECT * FROM emp WHERE sal BETWEEN 2000 AND 3000;

-- Index Skip Scan
-- 결합 인덱스 idx(emp(deptno, ename))에서 deptno 조건 없이 ename 조건만 있을 때
SELECT * FROM emp WHERE ename = 'KING';

-- Index Fast Full Scan
SELECT /*+ INDEX_FFS(emp emp_idx) */ empno FROM emp;
```

---

## ✅ 전체 구조 요약 테이블

| 범주         | 키워드 요약                                                                      |
| ---------- | --------------------------------------------------------------------------- |
| **탐색 구조**  | B-Tree 기반, 수직/수평 탐색, 결합 인덱스 구조 고려                                           |
| **사용 조건**  | WHERE절 조건 포함, 컬럼 가공 회피, 형변환 방지, 정렬 일치 여부 고려                                 |
| **비활용 원인** | 함수 사용, 자동 형변환, 선행 컬럼 누락, SELECT 리스트 가공                                      |
| **스캔 방식**  | Range Scan, Full Scan, Unique Scan, Skip Scan, Fast Full Scan, Descending 등 |

---

**📌 노션 정리 팁:**

* `2.1, 2.2, 2.3`을 **Toggle List로 분류**
* 각 소목차는 **Bullet + Table**로 구조화
* **예제는 코드 블록 형식으로 삽입**

---

---

## 📘 3장. 인덱스 튜닝

---

### 🔹 3.1 테이블 액세스 최소화

| 소목차                    | 요약                                                              |
| ---------------------- | --------------------------------------------------------------- |
| **3.1.1 테이블 랜덤 액세스**   | 인덱스를 통해 찾은 ROWID로 테이블을 무작위 접근하는 방식. 랜덤 액세스가 많을수록 I/O 부하 증가      |
| **3.1.2 인덱스 클러스터링 팩터** | 인덱스 순서와 실제 테이블 행 저장 순서의 일치 정도를 나타냄. 값이 작을수록 연속 블록 접근 가능성 높음     |
| **3.1.3 인덱스 손익분기점**    | 인덱스 사용이 테이블 Full Scan보다 이득이 되는 데이터 비율 기준. 선택도와 클러스터링 팩터에 따라 달라짐 |
| **3.1.4 인덱스 컬럼 추가**    | 커버링 인덱스 구성 목적으로 SELECT 절에 필요한 컬럼을 인덱스에 포함하여 테이블 접근 생략 유도        |
| **3.1.5 인덱스만 읽고 처리**   | Index-Only Scan 구현. 인덱스만으로 질의 결과를 도출하여 성능 향상 유도                 |
| **3.1.6 인덱스 구조 테이블**   | 인덱스 구조를 기준으로 물리적으로 재정렬된 테이블. 테이블 I/O 최적화 목적                     |
| **3.1.7 클러스터 테이블**     | 동일 키 값을 가지는 레코드들을 물리적으로 인접하게 저장하는 방식. 특정 질의에 대해 I/O 효율 향상 가능    |

#### ✅ 연습 예제

```sql
-- 인덱스 컬럼 추가로 커버링 인덱스 구성
CREATE INDEX emp_idx_cover ON emp(deptno, sal, ename);

-- 테이블 접근 생략 가능
SELECT ename FROM emp WHERE deptno = 10 AND sal > 3000;
```

---

### 🔹 3.2 부분범위 처리 활용

| 소목차                                     | 요약                                                      |
| --------------------------------------- | ------------------------------------------------------- |
| **3.2.1 부분범위 처리**                       | 전체 결과를 한 번에 처리하지 않고, 필요한 부분만 나누어 처리함으로써 자원 사용량 분산       |
| **3.2.2 부분범위 처리 구현**                    | `ROWNUM`, `ROWNUM BETWEEN`, `LIMIT OFFSET` 등 구문으로 구현 가능 |
| **3.2.3 OLTP 환경에서 부분범위 처리에 의한 성능개선 원리** | OLTP에서는 대량 데이터를 처리하는 쿼리보다 작은 단위의 질의 반복이 효율적. 응답시간 단축 유도 |

#### ✅ 연습 예제

```sql
-- 부분 범위 처리 구현
SELECT * FROM emp WHERE ROWNUM <= 10;

-- OFFSET 사용 (MySQL/Oracle 12c 이상)
SELECT * FROM emp ORDER BY empno OFFSET 10 ROWS FETCH NEXT 10 ROWS ONLY;
```

---

### 🔹 3.3 인덱스 스캔 효율화

| 소목차                                         | 요약                                                                 |
| ------------------------------------------- | ------------------------------------------------------------------ |
| **3.3.1 인덱스 탐색**                            | 인덱스에서 검색 조건과 일치하는 키 값을 찾아가는 과정. 루트-리프 구조에서 효율 판단 필요                |
| **3.3.2 인덱스 스캔 효율성**                        | 스캔 범위의 크기, 선택도, 불필요한 리프 노드 탐색 유무 등 고려하여 효율 측정                      |
| **3.3.3 액세스 조건과 필터 조건**                     | 액세스 조건은 인덱스 스캔을 제한, 필터 조건은 테이블 접근 후 필터링. 액세스 조건이 우선 적용되어야 성능 향상 가능 |
| **3.3.4 비교 연산자 종류와 컬럼 순서에 따른 군집성**          | =, <, BETWEEN 등의 조건과 컬럼 순서가 인덱스 사용 효율에 영향. 군집도가 낮으면 효율 저하          |
| **3.3.5 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율** | 선행 컬럼이 범위 조건일 경우 후속 컬럼 인덱스 사용 불가                                   |
| **3.3.6 BETWEEN을 IN-List로 전환**              | 인덱스 탐색 효율을 높이기 위해 범위 조건을 명시적 리스트로 분할                               |
| **3.3.7 Index Skip Scan 활용**                | 결합 인덱스에서 선행 컬럼 조건 없이 후속 컬럼 조건만으로도 인덱스 탐색 가능                        |
| **3.3.8 IN 조건은 ‘=’인가**                      | IN 조건은 OR과 유사하지만 내부적으로 반복되는 '=' 조건으로 인식되어 성능 최적화 가능                |
| **3.3.9 BETWEEN과 LIKE 스캔 범위 비교**            | LIKE는 와일드카드 사용 시 범위 탐색. BETWEEN은 정확한 범위 탐색 수행                      |
| **3.3.10 범위검색 조건을 남용할 때 생기는 비효율**           | 넓은 범위 지정 시 Full Scan으로 전환되거나 불필요한 블록 탐색 발생 가능성                     |
| **3.3.11 다양한 옵션 조건 처리 방식의 장단점 비교**          | OR, CASE, UNION 등 옵션 조건을 사용한 쿼리의 처리 방식 및 인덱스 효율 차이 비교              |
| **3.3.12 함수호출부하 해소를 위한 인덱스 구성**             | WHERE 절에서 사용하는 함수 결과를 계산하지 않도록 함수 결과를 인덱스에 포함하는 방식 (함수 기반 인덱스)     |

#### ✅ 연습 예제

```sql
-- 함수 기반 인덱스 구성
CREATE INDEX emp_idx_fn ON emp(UPPER(ename));

-- UPPER 사용 시에도 인덱스 가능
SELECT * FROM emp WHERE UPPER(ename) = 'KING';

-- BETWEEN을 IN으로 전환
SELECT * FROM emp WHERE empno BETWEEN 100 AND 103;
-- 아래처럼 분해 가능
SELECT * FROM emp WHERE empno IN (100, 101, 102, 103);
```

---

### 🔹 3.4 인덱스 설계

| 소목차                            | 요약                                                    |
| ------------------------------ | ----------------------------------------------------- |
| **3.4.1 인덱스 설계가 어려운 이유**       | 데이터 분포, 질의 패턴, 트랜잭션 특성 등 다양한 요소가 고려 대상. 고정된 공식 없음     |
| **3.4.2 가장 중요한 두 가지 선택 기준**    | 인덱스 선택도(중복도)와 질의 패턴. WHERE 조건에 자주 등장하는 컬럼을 중심으로 설계    |
| **3.4.3 스캔 효율성 이외의 판단 기준**     | INSERT/UPDATE 성능, 공간 사용량 등도 인덱스 설계 시 고려               |
| **3.4.4 공식을 초월한 전략적 설계**       | 고정된 규칙보다 실질적인 성능과 용도 중심의 설계 중요                        |
| **3.4.5 소트 연산을 생략하기 위한 컬럼 추가** | ORDER BY 조건을 인덱스 컬럼에 포함시켜 정렬 연산 생략 유도                 |
| **3.4.6 결합 인덱스 선택도**           | 결합 컬럼 중 하나라도 높은 선택도를 가지면 인덱스 효율 향상 가능                 |
| **3.4.7 중복 인덱스 제거**            | 동일한 컬럼 조합 또는 목적이 중복된 인덱스를 제거하여 자원 낭비 방지               |
| **3.4.8 인덱스 설계도 작성**           | 쿼리 특성, 조건 컬럼, 정렬 컬럼 등을 기준으로 설계 문서화 수행. 협업 및 유지보수에 효과적 |

#### ✅ 연습 예제

```sql
-- 중복 인덱스 확인
SELECT index_name, column_name
FROM user_ind_columns
WHERE table_name = 'EMP';

-- 설계도 예시 (설계 문서 형태로 관리)
-- 인덱스명: emp_idx_1
-- 대상 테이블: EMP
-- 컬럼: DEPTNO, SAL
-- 목적: 커버링 인덱스 + 정렬 생략
```

---

## ✅ 전체 구조 요약 테이블

| 범주             | 키워드 요약                                    |
| -------------- | ----------------------------------------- |
| **테이블 접근 최소화** | 클러스터링 팩터, 인덱스만 처리, 커버링 인덱스, 구조 테이블        |
| **부분 처리 활용**   | ROWNUM, OFFSET, 페이징 처리, OLTP 대응           |
| **스캔 효율화 전략**  | IN vs BETWEEN, 함수 인덱스, 선행 컬럼 조건, 필터 조건 구분 |
| **인덱스 설계 전략**  | 선택도, 컬럼 순서, 중복 제거, 설계 문서화, 정렬 생략 유도       |

---

**📌 노션 정리 팁:**

* `3.1 ~ 3.4`를 Toggle로 구성
* 각 소제목은 하위 bullet로 설명
* 연습 예제는 코드 블록 형태 삽입
* `중복 인덱스 제거`, `함수 기반 인덱스` 등은 태그 활용 추천

---



---

## 📘 4장. 조인 튜닝

---

### 🔹 4.1 NL 조인 (Nested Loop Join)

| 소목차                      | 요약                                                 |
| ------------------------ | -------------------------------------------------- |
| **4.1.1 기본 메커니즘**        | 외부 테이블의 각 행마다 내부 테이블을 탐색. 반복 루프 구조로 작동             |
| **4.1.2 NL 조인 실행계획 제어**  | 옵티마이저 힌트(`USE_NL`) 또는 통계 정보로 조인 방식 유도 가능           |
| **4.1.3 NL 조인 수행 과정 분석** | 외부 테이블 스캔 → 내부 테이블 인덱스 접근 또는 테이블 스캔으로 이루어짐         |
| **4.1.4 NL 조인 튜닝 포인트**   | 내부 테이블에 인덱스를 구축하거나, 외부 테이블의 건수 최소화 필요              |
| **4.1.5 NL 조인 특징 요약**    | 소량 데이터에 적합, 인덱스 의존도 높음, 반복 수행으로 CPU 부하 발생 가능       |
| **4.1.6 NL 조인 튜닝 실습**    | 실행계획 비교를 통해 NL 조인의 성능과 인덱스 유무 영향 확인                |
| **4.1.7 NL 조인 확장 메커니즘**  | Batched NL Join, Index Join 등 최적화된 NL 구조 도입 가능성 존재 |

#### ✅ 실습 예제

```sql
-- NL 조인 유도 힌트
SELECT /*+ USE_NL(e d) */ *
FROM emp e JOIN dept d ON e.deptno = d.deptno;
```

---

### 🔹 4.2 소트 머지 조인 (Sort Merge Join)

| 소목차                       | 요약                                              |
| ------------------------- | ----------------------------------------------- |
| **4.2.1 SGA vs. PGA**     | SM 조인은 정렬을 위한 PGA 메모리 공간 사용. SGA보다 병렬/대용량 처리 적합 |
| **4.2.2 기본 메커니즘**         | 양쪽 테이블을 정렬 후 병합. 인덱스 없이도 정렬만 되면 조인 가능           |
| **4.2.3 소트 머지 조인이 빠른 이유** | 정렬된 데이터의 병합만으로 처리되므로, CPU 부하 적고 병렬 처리 유리        |
| **4.2.4 소트 머지 조인의 주용도**   | 인덱스가 없거나 대량 데이터 조인 시 효과적. 정렬 연산을 전제로 작동         |
| **4.2.5 소트 머지 조인 제어하기**   | `USE_MERGE` 힌트나 정렬 전략을 통해 조인 방식 유도 가능           |
| **4.2.6 소트 머지 조인 특징 요약**  | 대용량에 적합, 인덱스 필요 없음, 정렬 비용 발생 가능, PGA 의존도 존재     |

#### ✅ 실습 예제

```sql
-- SM 조인 유도 힌트
SELECT /*+ USE_MERGE(e d) */ *
FROM emp e JOIN dept d ON e.deptno = d.deptno;
```

---

### 🔹 4.3 해시 조인 (Hash Join)

| 소목차                          | 요약                                              |
| ---------------------------- | ----------------------------------------------- |
| **4.3.1 기본 메커니즘**            | 한쪽 테이블을 메모리에 해시 테이블로 빌드하고, 다른 테이블과 해시 비교 수행     |
| **4.3.2 해시 조인이 빠른 이유**       | 정렬 불필요, 인덱스 미사용 시에도 빠르게 탐색 가능. 중복이 적은 경우 유리     |
| **4.3.3 대용량 Build Input 처리** | 빌드 입력이 커지면 파티셔닝하거나 디스크 스풀링 사용. 메모리 크기 조절 중요     |
| **4.3.4 해시 조인 실행계획 제어**      | `USE_HASH` 힌트를 통해 강제 유도 가능. 빌드/프로브 테이블 순서 고려 필요 |
| **4.3.5 조인 메소드 선택 기준**       | 데이터 양, 인덱스 유무, 정렬 비용, 실행 계획 등 종합적 판단 기반 선택 필요   |

#### ✅ 실습 예제

```sql
-- 해시 조인 유도 힌트
SELECT /*+ USE_HASH(e d) */ *
FROM emp e JOIN dept d ON e.deptno = d.deptno;
```

---

### 🔹 4.4 서브쿼리 조인

| 소목차                       | 요약                                                |
| ------------------------- | ------------------------------------------------- |
| **4.4.1 서브쿼리 변환이 필요한 이유** | 상관 서브쿼리는 반복 실행 구조로 비효율 발생. JOIN으로 변환 필요           |
| **4.4.2 서브쿼리와 조인**        | EXISTS, IN 등 서브쿼리는 NL 구조로 작동하므로 조인으로 바꾸면 성능 개선 가능 |
| **4.4.3 뷰(View)와 조인**     | 인라인 뷰 또는 머티리얼라이즈드 뷰의 조인 처리 방식 분석 필요. 병합 시 최적화 가능  |
| **4.4.4 스칼라 서브쿼리 조인**     | SELECT 절 내부 서브쿼리는 조인으로 변환 불가. 반복 실행 구조로 성능 저하 가능  |

#### ✅ 실습 예제

```sql
-- 서브쿼리를 조인으로 변환
-- Before (서브쿼리)
SELECT ename FROM emp WHERE deptno IN (SELECT deptno FROM dept WHERE loc = 'DALLAS');

-- After (조인)
SELECT e.ename
FROM emp e JOIN dept d ON e.deptno = d.deptno
WHERE d.loc = 'DALLAS';
```

---

## ✅ 전체 조인 방식 비교 요약 표

| 조인 방식        | 특징 요약                                      |
| ------------ | ------------------------------------------ |
| **NL 조인**    | 소량 데이터에 적합, 인덱스 필요, 반복 수행 구조, CPU 부하 높음    |
| **소트 머지 조인** | 대용량, 인덱스 불필요, 정렬 기반, 병렬 처리 유리              |
| **해시 조인**    | 중간 규모 이상, 인덱스 불필요, 해시 연산 기반, 빌드 테이블 메모리 의존 |
| **서브쿼리 조인**  | 반복 구조 성능 저하 위험, 조인 변환 필요, EXISTS/IN 주의     |
| **스칼라 서브쿼리** | SELECT 절 내부 반복 실행, 대량 처리 시 성능 저하           |

---

## ✅ 노션 정리 팁

* `4.1 ~ 4.4`를 Toggle로 분류
* 각 소제목은 Bullet 형식으로 설명
* 조인 방식 비교는 Table block으로 구성
* 힌트와 실습은 Code block 활용

---


---

## 📘 5장. 소트 튜닝

---

### 🔹 5.1 소트 연산에 대한 이해

| 소목차                | 요약                                                                                         |
| ------------------ | ------------------------------------------------------------------------------------------ |
| **5.1.1 소트 수행 과정** | SQL 실행 시 발생하는 소트 연산은 메모리(PGA)를 우선 사용하고 부족 시 TEMP 공간 사용. Disk 소트 발생 시 성능 저하 유발              |
| **5.1.2 소트 오퍼레이션** | `ORDER BY`, `GROUP BY`, `UNION`, `DISTINCT`, 분석 함수 등에서 자동 소트 연산 발생. 실행계획에서 `SORT` 연산 확인 필요 |

#### ✅ 실습 예제

```sql
-- 실행계획에서 SORT 확인
EXPLAIN PLAN FOR SELECT * FROM emp ORDER BY sal;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

---

### 🔹 5.2 소트가 발생하지 않도록 SQL 작성

| 비교 항목         | 소트 발생 가능성 | 설명                         |
| ------------- | --------- | -------------------------- |
| **UNION**     | 높음        | 중복 제거를 위해 소트 수행            |
| **UNION ALL** | 없음        | 중복 제거 없음, 소트 불필요           |
| **EXISTS**    | 낮음        | 서브쿼리의 존재 여부만 판단. 결과 정렬 불필요 |

| 소목차                           | 요약                                                                       |
| ----------------------------- | ------------------------------------------------------------------------ |
| **5.2.1 UNION vs. UNION ALL** | `UNION`은 내부적으로 중복 제거용 소트 수행. 중복 제거 필요 없으면 `UNION ALL` 사용으로 소트 생략 통제      |
| **5.2.2 EXISTS 활용**           | `IN` 대비 `EXISTS`는 정렬을 유도하지 않으며, 서브쿼리에서 빠른 종료 가능성 있음. 소트 오퍼레이션 최소화 가능성 존재 |

#### ✅ 실습 예제

```sql
-- 소트 발생
SELECT deptno FROM emp UNION SELECT deptno FROM dept;

-- 소트 없음
SELECT deptno FROM emp UNION ALL SELECT deptno FROM dept;
```

---

### 🔹 5.3 인덱스를 이용한 소트 연산 생략

| 활용 기법                      | 요약                                                                          |
| -------------------------- | --------------------------------------------------------------------------- |
| **5.3.1 Sort Order By 생략** | `ORDER BY` 컬럼이 인덱스 정렬 순서와 일치하면 정렬 생략 가능. 실행계획에서 `SORT ORDER BY` 제거 여부 확인 필요 |
| **5.3.2 Top N 쿼리**         | 정렬 후 상위 N건만 추출하는 쿼리. 인덱스를 활용해 정렬 생략 또는 최소화 가능                               |
| **5.3.3 최소값/최대값 구하기**      | 인덱스 최상단 또는 최하단 값을 참조하여 MIN/MAX 수행. 정렬 불필요                                   |
| **5.3.4 이력 조회**            | 날짜 역순 정렬 시 인덱스 포함 컬럼 정렬로 소트 생략 가능                                           |
| **5.3.5 Sort Group By 생략** | GROUP BY 컬럼이 인덱스에 포함되면 정렬 없이 해시 집계 방식 사용 가능                                 |

#### ✅ 실습 예제

```sql
-- 최소값 인덱스만으로 구하기
SELECT MIN(sal) FROM emp;

-- 이력 조회
SELECT * FROM emp WHERE deptno = 10 ORDER BY hiredate DESC FETCH FIRST 1 ROW ONLY;
```

---

### 🔹 5.4 Sort Area를 적게 사용하도록 SQL 작성

| 소목차                                 | 요약                                                                     |
| ----------------------------------- | ---------------------------------------------------------------------- |
| **5.4.1 소트 데이터 줄이기**                | WHERE절로 대상 행 축소, SELECT 컬럼 수 최소화 등으로 소트 대상 줄임                          |
| **5.4.2 Top N 쿼리의 소트 부하 경감 원리**     | 전체 정렬 대신 인덱스 기반 상위 N개만 추출하면 메모리 및 TEMP 사용량 감소                          |
| **5.4.3 Top N 쿼리가 아닐 때 발생하는 소트 부하** | 전 테이블 정렬 시 TEMP 공간 사용 증가. 소트 버퍼 사이즈 부족 시 Disk I/O 증가                   |
| **5.4.4 분석함수에서의 Top N 소트**          | `RANK()`, `ROW_NUMBER()` 등은 내부 정렬 필요. PARTITION BY, ORDER BY 구조 최적화 필요 |

#### ✅ 실습 예제

```sql
-- 분석 함수 Top N
SELECT ename, sal,
       RANK() OVER (PARTITION BY deptno ORDER BY sal DESC) AS sal_rank
FROM emp
WHERE deptno = 10;

-- 불필요한 소트 부하 회피 위해 인덱스 존재 여부 확인 필요
```

---

## ✅ 소트 회피 전략 요약 표

| 전략 분류            | 대표 기법                       | 효과 요약                 |
| ---------------- | --------------------------- | --------------------- |
| **불필요한 소트 제거**   | `UNION ALL`, `EXISTS`       | 소트 연산 자체 제거 가능        |
| **인덱스 기반 소트 생략** | `ORDER BY` 인덱스 컬럼, MIN/MAX  | 정렬 생략으로 성능 향상         |
| **데이터 축소**       | WHERE, LIMIT                | 메모리 사용량 및 TEMP I/O 감소 |
| **분석 함수 최적화**    | PARTITION + ORDER BY 정렬 최적화 | 소트 부하 감소 통제           |

---

## ✅ 노션 정리 팁

* `5.1 ~ 5.4`는 Toggle로 구분
* 각 소제목은 Bullet 구조로 설명
* 실습 예제는 Code Block으로 삽입
* 소트 전략 요약은 Table 블록으로 구성
* `정렬 생략`, `인덱스 활용`, `TEMP 최소화` 등 주요 키워드는 Tag 처리 추천

---

다음은 **SQLP 관련 도서 6장: DML 튜닝**에 대한 각 목차별 예측 요약입니다.
각 소목차 단위로 정리하며, **비슷한 주제는 표로 통합**, **실습 예제 포함**, **노션에 정리하기 적합한 서식**으로 제공합니다.
문장은 `~설명`, `~통제`, `~이해 필요` 등으로 종결하며, 핵심은 **성능 최적화를 위한 DML 전략 수립**입니다.

---

## 📘 6장. DML 튜닝

---

### 🔹 6.1 기본 DML 튜닝

| 소목차                                 | 요약                                                         |
| ----------------------------------- | ---------------------------------------------------------- |
| **6.1.1 DML 성능에 영향을 미치는 요소**        | 트리거, 인덱스 수, 로우 크기, 제약조건 등 DML 처리 시 부하 요인 존재. 사전 분석 필요      |
| **6.1.2 데이터베이스 Call과 성능**           | DML 1건당 1 Call보다 다건 처리 시 성능 우수. 네트워크 왕복 및 Parse 비용 절감 유도   |
| **6.1.3 Array Processing 활용**       | 배열 단위로 바인드 처리 시 DML 성능 대폭 향상. JDBC 등의 Batch 처리도 포함됨        |
| **6.1.4 인덱스 및 제약 해제를 통한 대량 DML 튜닝** | 대량 삽입/갱신 시 인덱스/제약조건을 일시 해제하고 작업 후 재적용하면 부하 최소화             |
| **6.1.5 수정가능 조인 뷰**                 | 기본키 포함 조건 등 충족 시 조인 뷰를 통해 직접 UPDATE/DELETE 가능. 복잡한 구조는 제한됨 |
| **6.1.6 MERGE 문 활용**                | INSERT/UPDATE를 하나로 통합한 DML. UPSERT 방식 처리 시 유용              |

#### ✅ 실습 예제

```sql
-- MERGE 문 예제
MERGE INTO emp e
USING (SELECT 7900 empno, 'JACK' ename FROM dual) src
ON (e.empno = src.empno)
WHEN MATCHED THEN UPDATE SET e.ename = src.ename
WHEN NOT MATCHED THEN INSERT (empno, ename) VALUES (src.empno, src.ename);
```

---

### 🔹 6.2 Direct Path I/O 활용

| 소목차                          | 요약                                                                                       |
| ---------------------------- | ---------------------------------------------------------------------------------------- |
| **6.2.1 Direct Path I/O**    | 버퍼 캐시를 우회하여 데이터를 디스크에서 직접 읽고 씀. 대량 데이터 작업에 적합                                            |
| **6.2.2 Direct Path Insert** | APPEND 힌트를 통해 Direct Insert 유도. 기존 블록 무시하고 데이터 파일 끝에 삽입                                  |
| **6.2.3 병렬 DML**             | `PARALLEL` 힌트 또는 `ALTER SESSION ENABLE PARALLEL DML`을 통해 대량 작업 병렬 처리. DDL과의 조합 가능성 고려 필요 |

#### ✅ 실습 예제

```sql
-- Direct Path Insert
INSERT /*+ APPEND */ INTO emp SELECT * FROM emp_backup;

-- 병렬 DML 활성화
ALTER SESSION ENABLE PARALLEL DML;
INSERT /*+ PARALLEL(emp, 4) */ INTO emp SELECT * FROM emp_staging;
```

---

### 🔹 6.3 파티션을 활용한 DML 튜닝

| 소목차                             | 요약                                                        |
| ------------------------------- | --------------------------------------------------------- |
| **6.3.1 테이블 파티션**               | 파티션 단위로 데이터를 분할하여 INSERT/DELETE/UPDATE 대상 축소. I/O 감소 유도   |
| **6.3.2 인덱스 파티션**               | 테이블 파티션과 일치 또는 독립 설계 가능. 로컬 인덱스 사용 시 병렬 작업에 유리            |
| **6.3.3 파티션을 활용한 대량 UPDATE 튜닝** | 파티션 교체 또는 파티션 대상 범위 UPDATE로 수정 대상 최소화                     |
| **6.3.4 파티션을 활용한 대량 DELETE 튜닝** | `ALTER TABLE ... DROP PARTITION`을 통해 삭제 대신 파티션 제거로 부하 최소화 |
| **6.3.5 파티션을 활용한 대량 INSERT 튜닝** | 병렬 INSERT 시 파티션별로 작업 분산 가능. INSERT 속도 향상 기대               |

#### ✅ 실습 예제

```sql
-- 파티션 테이블 생성 예시
CREATE TABLE sales (
  sale_id NUMBER,
  sale_date DATE
) PARTITION BY RANGE (sale_date) (
  PARTITION p_2023 VALUES LESS THAN (TO_DATE('2024-01-01','YYYY-MM-DD')),
  PARTITION p_2024 VALUES LESS THAN (MAXVALUE)
);

-- 파티션 DROP
ALTER TABLE sales DROP PARTITION p_2023;
```

---

### 🔹 6.4 Lock과 트랜잭션 동시성 제어

| 소목차                              | 요약                                                            |
| -------------------------------- | ------------------------------------------------------------- |
| **6.4.1 오라클 Lock**               | TM(TX) 락을 통한 행/테이블 수준 잠금 관리. DML 충돌 시 대기 및 경합 가능성 분석 필요       |
| **6.4.2 트랜잭션 동시성 제어**            | COMMIT/ROLLBACK 타이밍 조정 및 적절한 격리 수준 선택 필요. 부적절한 Lock은 성능 저하 유발 |
| **6.4.3 채번 방식에 따른 INSERT 성능 비교** | 시퀀스 직접 사용, 서브쿼리 채번, UUID 등 각기 성능 차이 존재. 시퀀스 + 캐시 전략 권장        |

#### ✅ 실습 예제

```sql
-- 채번 방식 비교 예제
-- 1) 일반 시퀀스
INSERT INTO emp(empno, ename) VALUES(emp_seq.NEXTVAL, 'SCOTT');

-- 2) 서브쿼리 방식 (비효율 가능성)
INSERT INTO emp(empno, ename)
VALUES((SELECT MAX(empno) + 1 FROM emp), 'SCOTT');
```

---

## ✅ DML 튜닝 전략 요약 표

| 전략 범주              | 대표 기법                            | 효과 요약             |
| ------------------ | -------------------------------- | ----------------- |
| **기본 DML 최적화**     | Array Processing, MERGE          | 호출 수 감소, 코드 간결화   |
| **Direct Path 활용** | APPEND, PARALLEL                 | 캐시 우회, 병렬 처리      |
| **파티셔닝 기반 처리**     | 파티션 DROP, LOCAL Index, UPDATE 제한 | 작업 범위 축소, I/O 최소화 |
| **Lock 제어**        | Lock 모니터링, 트랜잭션 분리 수준            | 경합 방지, 트랜잭션 충돌 완화 |
| **채번 전략**          | 시퀀스 vs. 서브쿼리                     | 시퀀스 캐시 기반이 가장 우수  |

---

## ✅ 노션 정리 팁

* `6.1 ~ 6.4`는 Toggle List로 구분
* 각 소목차는 Bullet 형식 + 예제는 Code block 활용
* 전략 요약은 Table block으로 구성
* 태그: `#MERGE`, `#DirectPath`, `#Partition`, `#Lock`, `#ArrayProcessing`

---


---

## 📘 7장. SQL 옵티마이저

---

### 🔹 7.1 통계정보와 비용 계산 원리

| 소목차                  | 요약                                                                                            |
| -------------------- | --------------------------------------------------------------------------------------------- |
| **7.1.1 선택도와 카디널리티** | \*\*선택도(Selectivity)\*\*는 조건에 부합하는 비율, \*\*카디널리티(Cardinality)\*\*는 예상 반환 행 수. 옵티마이저의 비용 계산 기반 |
| **7.1.2 통계정보**       | 테이블, 인덱스, 컬럼, 히스토그램 정보 포함. 최신 통계가 아닌 경우 부정확한 실행계획 생성 가능성 존재                                   |
| **7.1.3 비용 계산 원리**   | I/O 비용, CPU 연산, 네트워크 비용 등 다양한 요소를 기반으로 각 실행계획의 비용(B cost)을 산정하여 최저 비용 경로 선택                   |

#### ✅ 실습 예제

```sql
-- 통계 확인
SELECT table_name, num_rows, blocks, avg_row_len
FROM user_tables WHERE table_name = 'EMP';

-- 통계 갱신
EXEC DBMS_STATS.GATHER_TABLE_STATS(ownname => 'SCOTT', tabname => 'EMP');
```

---

### 🔹 7.2 옵티마이저에 대한 이해

| 소목차                         | 요약                                                                                                          |
| --------------------------- | ----------------------------------------------------------------------------------------------------------- |
| **7.2.1 옵티마이저 종류**          | **RBO**(Rule-Based Optimizer): 과거 방식, 규칙 기반 경로 선택. <br> **CBO**(Cost-Based Optimizer): 현재 주류, 통계정보 기반 비용 평가 |
| **7.2.2 옵티마이저 모드**          | ALL\_ROWS(처리 효율), FIRST\_ROWS(빠른 응답), FIRST\_ROWS\_n 등. 튜닝 목표에 따라 설정 필요                                     |
| **7.2.3 옵티마이저에 영향을 미치는 요소** | 통계정보, 힌트, 바인드 변수, 파라미터 값, 인덱스 유무 등 다양한 요인 존재. 튜닝 전 환경 분석 필수                                                 |
| **7.2.4 옵티마이저의 한계**         | 실제 데이터 분포, 상관 서브쿼리, 함수 내 조건 처리 등에서 오류 발생 가능. **선택도 예측 실패** 주요 원인                                            |
| **7.2.5 개발자의 역할**           | 정확한 통계 제공, SQL 구조 단순화, 힌트 사용 등으로 옵티마이저의 오판 방지 유도 필요                                                         |
| **7.2.6 튜닝 전문가 되는 공부방법**    | 실행계획 분석 연습, 옵티마이저 힌트 실습, 통계 조작 및 시나리오 기반 튜닝 반복 훈련 필요                                                        |

---

## ✅ 옵티마이저 종류 및 모드 요약 표

| 구분           | 종류/모드          | 설명                             |
| ------------ | -------------- | ------------------------------ |
| **옵티마이저 종류** | RBO            | 규칙 기반, 인덱스 우선 적용 등 명시적 우선순위 존재 |
|              | CBO            | 비용 기반, 통계정보로 비용 계산 후 실행계획 선택   |
| **옵티마이저 모드** | ALL\_ROWS      | 전체 처리 성능 위주, 대량 일괄 처리에 적합      |
|              | FIRST\_ROWS    | 응답 시간 위주, OLTP 환경에 적합          |
|              | FIRST\_ROWS\_n | 상위 N건 빠른 반환 우선. 페이징 최적화 시 유용   |

#### ✅ 실습 예제

```sql
-- 옵티마이저 모드 변경 (세션 단위)
ALTER SESSION SET optimizer_mode = FIRST_ROWS_10;

-- 힌트로 강제 제어
SELECT /*+ FIRST_ROWS(1) */ * FROM emp WHERE deptno = 10;
```

---

## ✅ SQL 옵티마이저 핵심 요약

| 영역            | 핵심 내용                              |
| ------------- | ---------------------------------- |
| **선택도/카디널리티** | 실행계획 비용 산정의 기준. 통계와 조건절에 따라 결정됨    |
| **통계정보**      | 최신화 여부가 정확한 경로 선택에 중요. 자동/수동 갱신 필요 |
| **옵티마이저 종류**  | CBO 중심 체계, 힌트 및 환경 설정으로 경로 제어 가능   |
| **개발자의 역할**   | SQL 구조 최적화, 힌트 활용, 통계 관리 주도 등      |

---

## ✅ 노션 정리 팁

* `7.1`과 `7.2`를 Toggle로 나누고, 각 항목은 Bullet 형태로 구성
* `옵티마이저 종류/모드 표`, `핵심 요약 표`는 Table block으로 정리
* `통계 갱신`, `힌트`, `옵티마이저 모드 변경` 등은 Code block으로 삽입
* 태그 예시: `#CBO`, `#통계정보`, `#카디널리티`, `#FIRST_ROWS`, `#SQL튜닝`

---


---

## 📘 부록. SQL 분석 도구

---

### 🔹 1. 실행계획 확인

* `EXPLAIN PLAN` 구문을 사용하여 SQL 문장의 내부 실행 흐름을 분석
* 테이블 액세스 방식(Index Range Scan, Full Table Scan 등) 및 조인 순서 확인 가능
* 실행 전 계획만을 보여주므로 실제 실행 비용과 다를 수 있음

#### ✅ 실습 예제

```sql
EXPLAIN PLAN FOR
SELECT * FROM emp WHERE deptno = 10;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

---

### 🔹 2. AutoTrace

* SQLPlus에서 제공하는 기능
* 실행계획과 통계정보를 동시에 출력해 SQL의 성능 진단 가능
* `AUTOTRACE TRACEONLY` 옵션으로 통계만, `STATISTICS`로 I/O, CPU 사용량 확인 가능

#### ✅ 실습 예제

```sql
SET AUTOTRACE ON
SELECT * FROM emp WHERE empno = 7369;

-- 통계만 보고 싶을 경우
SET AUTOTRACE TRACEONLY STATISTICS
```

---

### 🔹 3. SQL 트레이스

* SQL 수행 과정의 모든 단계를 상세하게 기록하는 저수준 추적 도구
* `10046 이벤트`와 함께 사용 시 대기 이벤트 및 바인드 변수까지 확인 가능
* 성능 병목 분석 및 개발자 디버깅에 유용

#### ✅ 실습 예제

```sql
-- 세션 레벨에서 트레이스 시작
ALTER SESSION SET sql_trace = TRUE;

-- 트레이스 종료
ALTER SESSION SET sql_trace = FALSE;

-- 결과 분석: TKPROF 유틸리티 활용
```

---

### 🔹 4. DBMS\_XPLAN 패키지

* EXPLAIN PLAN 결과를 다양한 포맷으로 확인 가능한 패키지
* `DISPLAY_CURSOR`를 활용하면 **실제 실행된 SQL의 실행계획**도 출력 가능
* `ALLSTATS LAST` 옵션으로 실행 통계까지 함께 출력 가능

#### ✅ 실습 예제

```sql
-- 실행 중 SQL의 실제 실행계획 확인
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(null, null, 'ALLSTATS LAST'));
```

---

### 🔹 5. 실시간 SQL 모니터링

* Oracle Enterprise Edition에서 지원
* `V$SQL_MONITOR`를 통해 Active SQL의 실시간 실행 상태를 모니터링
* 긴 실행 시간, 병렬 처리 SQL 추적에 효과적

#### ✅ 실습 예제

```sql
-- 실행 중 SQL 모니터링
SELECT * FROM V$SQL_MONITOR WHERE status = 'EXECUTING';
```

---

### 🔹 6. V\$SQL

* Shared Pool에 존재하는 SQL의 실행 계획, 실행 횟수, 평균 소요 시간, I/O 등 다양한 정보를 제공
* 튜닝 대상 SQL을 식별하는 데 효과적

#### ✅ 실습 예제

```sql
-- 자주 수행되며 비용이 높은 SQL 확인
SELECT sql_id, executions, elapsed_time/1000000 elapsed_secs, sql_text
FROM V$SQL
WHERE executions > 10
ORDER BY elapsed_secs DESC;
```

---

## ✅ SQL 분석 도구 기능 비교표

| 도구               | 용도 요약                              | 실시간 여부 | 실행계획      | 통계정보 | 트레이스 |
| ---------------- | ---------------------------------- | ------ | --------- | ---- | ---- |
| **EXPLAIN PLAN** | 실행 전 계획 확인                         | ✕      | ✅         | ✕    | ✕    |
| **AutoTrace**    | 실행계획 + 통계 확인                       | ✕      | ✅         | ✅    | ✕    |
| **SQL 트레이스**     | 병목 구간 추적용 저수준 이벤트 기록               | ✕      | ✅ (결과 분석) | ✅    | ✅    |
| **DBMS\_XPLAN**  | 다양한 방식의 실행계획 출력 (`DISPLAY_CURSOR`) | ✅      | ✅         | ✅    | ✕    |
| **SQL 모니터링**     | 현재 수행 중인 SQL 모니터링 (Enterprise 한정)  | ✅      | ✅         | ✅    | ✕    |
| **V\$SQL**       | Shared Pool에 존재하는 SQL의 실행 통계 확인    | ✅      | ✅ (간략)    | ✅    | ✕    |

---

## ✅ 노션 정리 팁

* 각 항목을 Toggle로 구성
* 실습 예제는 Code Block으로 삽입
* 분석 도구 비교는 Table Block으로 요약
* 태그 예시: `#DBMS_XPLAN`, `#SQL_TRACE`, `#EXPLAIN_PLAN`, `#SQL_MONITOR`

---
